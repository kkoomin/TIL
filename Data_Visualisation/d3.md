# D3.js

## Getting started with D3

### Setting up your environment

- https://github.com/adamjanes/udemy-d3
- http-server 세팅 : 로컬에서 파일을 돌릴 수 있도록
- npm i -g http-server → http-server 돌리면 localhost:8080으로 로컬 서버가 뜸

### Understanding SVGs

- svg : 공간을 많이 차지하지 않고 이미지가 깨지지 않기 때문에 사용
- `<svg></svg>`로 svg 캔버스 영역을 잡음
    - svg tag represents the canvas that will be drawing on
- 좌표를 svg 태그 영역 밖으로 잡아서 모양을 그리면 캔버스 밖은 랜더링되지 않음
- stroke → border 역할
- rect → x, y 좌표 필요. w, h 길이 필요    
- circle, ellipse → r로 커브 설정
- line → 2 sets of coordinates needed (x1, y1, x2, y2)
- text → 시작하는 좌표를 제공하고, 사이즈와 fill을 설정하여 폰트 사이즈, 컬러링
- path → 가장 Powerful. 복잡한 형태를 그림


### Adding SVGs with D3

- D3 Select - grab hold of elements on the screen    
- D3 Append - add SVGs onto your selection
- D3 Attr - set attributes of SVGs to make them appear on the screen    
- Method chaining in D3    

### Selections and data joins

- Data Driven Documents

```jsx
const data = [25, 20, 10, 12, 15]

const svg = d3.select("#chart-area").append("svg")
	.attr("width", 400)
	.attr("height", 400)

const circles = svg.selectAll("circle")
	.data(data)

circles.enter().append("circle")
	.attr("cx", (d, i) => (i * 50) + 50)
	.attr("cy", 250)
	.attr("r", (d) => d)
	.attr("fill", "red")
```

- .attr의 두번째 params에 function을 넣기 (d: data/item, i: index)

### Loading external data

- loading external data from CSV, TSV, and JSON files
    - 모두 같은 방식으로 data를 받는다
    - using Promises → using .then() method or callback
- Using map functions to format our raw text data
    
    ```jsx
    /*
    	[
    	{
    		"name": "Tony",
    		"age": "10"
    	},
    	{
    		"name": "Jessica",
    		"age": "12"
    	},
    	{
    		"name": "Andrew",
    		"age": "9"
    	},
    	{
    		"name": "Emily",
    		"age": "10"
    	},
    	{
    		"name": "Richard",
    		"age": "11"
    	}
    ]
    */
    
    d3.json("data/ages.json").then(data => {
    	data.forEach(d => {
    		d.age = Number(d.age)
    	}) // convert string value to integer
    	
    	const svg = d3.select("#chart-area").append("svg")
    	.attr("width", 400)
    	.attr("height", 400)
    
    	const circles = svg.selectAll("circle")
    		.data(data)
    
    	circles.enter().append("circle")
    		.attr("cx", (d, i) => (i * 50) + 50) 
    			// stagger the rects by their x coordinates
    		.attr("cy", 250)
    		.attr("r", (d) => 2 * d.age)
    		.attr("fill", d => {
    			if (d.name === "Tony") {
    				return "blue"
    			}
    			else {
    				return "red"
    			}
    		})
    }).catch(error => { // error handling needed when there's no file on given path
    	console.log(error)
    })
    ```
    
- Setting attributes of our SVGs with anonymous functions

## Scales and Axes
https://github.com/zziuni/d3/wiki/Quantitative-Scales#linear_invert   

### Linear Scales

- Scale = 척도
- Scales are functions that map from an input domain to and output range.
- Linear scale is for the bars scaled proportionally to their values

### Logarithmic Scales

- When to use? When the data is increasing exponentially over time.
- The domain for log scale needs to be either strictly positive or strictly negative cuz the log of zero is always undefined.

### Time Scales

- A special type of linear scale
- Time scales take JS date objects in their domain.

### Ordinal Scales

- For assigning colour schemes to categorical data (to associate two different categories)

### Band Scales

- Svg rectangles can be spaced out by scale, rather than by a fixed number of pixels.
- width and exposition values. Discrete domain, continuous range

### D3 min, max, and extent

- Setting the domains of our scales automatically based on the data that we're looking at.
- Calculating min, max, and extent values by d3 method

### Margins and groups

- Groups are invisible containers for structuring SVGs.
- Groups don't have any visual presence by themselves, but they are useful in D3 as they can bundle graphical elements together and apply transformations to many shapes at once.
- Have translation attributes for moving multiple SVGs at once.

### Axes and labels

- Using D3 axis generators in our bar chart to show the scale of our chart
- Adding axis labels to tell us what we're looking at


## The basics of design
### Designing for clarity

- Edward Tufle's design principles
    - Graphical integrity
    - The lie factor
    - Chart junk
    - Data-to-link ratio

### Subjectivity in design

- Important goals for visualization
    - Grab user's attention
    - Encourage further exploration
    - Build new and interesting types of visualizations
    

### Critiquing visualizations

- What is the visualization trying to do?
- Does this visualization contain a lie factor?
- How high is the data-link ratio?
- How would you rank the visualization on a scale of 1-10?

### The design toolkit

- Some channels are better at expressing data than others
        
- Types of data
        
    - Quantitative (numerical)
        - e.g. 1,2,3, 0.1, 0.43, 10%, 3/4, etc...
    - Categorical (categories)
        - e.g. African, Asian, male, female, etc...
    - Ordinal (rankings)
        - e.g. big, small, tall, short, low IQ, etc..
- Colour Selection
    - Don't use more than 5-8 colours for categories
    - Don't use diverging colour scale for quantitative data
    - Consider colour blind users (~5% of the population)
    - REF : [https://colorbrewer2.org/](https://colorbrewer2.org/)

### An Introduction to sketching

- Why do we need to draw sketches?
    - Figuring out how your site should look before diving into the programming
    - Thinking through the different options of how to communicate your data
    - Communicating abstract ideas to clients and colleagues
- Rules for sketching
    - Write your sketches on paper - make them disposable
    - Make your sketches big - at least half a size of A4/letter paper
    - Get the general point across - don't worry about the details, do quick and simple



## Make it dynamic
### Looping with intervals

```jsx
d3.interval(() => {}, 500)

const myInterval = setInterval(() => {}, 500) // create a new loop
clearInterval(myInterval) // stop the loop
```

### The D3 update pattern

```jsx
// DATA JOIN
// join new data with old elements (if any)
const text = svg.selectAll("text").data(data);

// EXIT
// remove old elements as needed.
text.exit().remove();

// UPDATE
// update old elements as needed
text.attr("fill", "red");

// ENTER
// create new elements as needed
rects.enter().append("text")
	.attr("x", (d, i) => i * 32)
	.attr("y", 0)
	.attr("fill", "green")
	.text(d => d);
```

1. DATA JOIN
    - select all matching elements on the screen with selectAll, and update the data that we're using
2. EXIT
    - use the exit() selector to remove the elements that don't exist in our new array of data.
3. UPDATE
    - set attributes for existing elements on the screen
4. ENTER
    - use the enter() selector to set attributes for new items in our data array
    

### D3 transitions

```jsx
rects.enter().append("rect")
	.attr("x", d => x(d.month))
	.attr("y", d => y(0))
	.attr("height", d => HEIGHT - y(d.revenue))
	.attr("width", x.bandwidth)
	.attr("fill", "grey")
	.attr("fill-opacity", 1)
	.transition(d3.transition().duration(500)) // transition
		.attr("y", d => y(d.revenue)
		.attr("fill-opacity", 0);
```